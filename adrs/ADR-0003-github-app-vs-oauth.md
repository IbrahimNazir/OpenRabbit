# ADR-0003: GitHub App over OAuth App for GitHub Integration

| Field | Value |
|-------|-------|
| **ID** | ADR-0003 |
| **Status** | ✅ Accepted |
| **Deciders** | Core Team |
| **Date** | Day 1 — Project Foundation |
| **Sprint Phase** | Phase 1: MVP |
| **Tags** | github, authentication, integration, multi-tenant |

---

## Context and Problem Statement

OpenRabbit must integrate with GitHub to: receive webhook events for PR opens/updates, read repository contents (to fetch diffs and file content), and post review comments back to pull requests. There are three ways to authenticate GitHub API requests as a third-party application.

The choice determines the rate limits we operate under, how we handle multi-tenancy (reviewing PRs across many different organizations), what permissions we can request, and how users install the tool.

---

## Decision Drivers

1. **Multi-tenant by default** — OpenRabbit will review PRs across many independent GitHub organizations and users. Each "tenant" is a GitHub organization or personal account that installs the app.
2. **Fine-grained permissions** — We need Read access to repository contents and Read+Write access to pull requests. We should request only these permissions and nothing more.
3. **Rate limit headroom** — GitHub enforces rate limits per-authenticating-entity. We need high limits to handle burst PR activity.
4. **Installation-scoped tokens** — Security best practice: a token that can only access the specific repositories that an org administrator has approved.
5. **No user login required** — OpenRabbit should work without requiring each repository owner to log in to a web UI. Installation via GitHub Marketplace or direct app install page is sufficient.
6. **Webhook delivery** — The integration must receive webhooks scoped to installed repositories only.

---

## Considered Options

### Option A: GitHub App (CHOSEN)

A GitHub App is a first-class GitHub entity registered once, installed by org admins, and acts as itself (not as any user).

**Authentication mechanism:**
1. App authenticates to GitHub using a JWT signed with its RSA private key (App-level auth, valid 10 minutes)
2. App exchanges the JWT for an Installation Access Token scoped to a specific installation (valid 1 hour)
3. All API calls for a given org/repo use that installation's token

**Rate limits:**
- 15,000 API requests/hour per installation (vs 5,000/hour for OAuth)
- Higher limits for GraphQL

**Permissions:**
- Admin specifies exactly which repositories the app can access at install time
- App requests minimum permission set (Pull Requests: RW, Contents: R, Metadata: R)

**Webhooks:**
- GitHub delivers webhooks directly to the app's configured URL, filtered to installed repositories
- Webhook payload includes `installation.id` — the key for looking up the right access token

### Option B: OAuth App

An OAuth App authenticates as a user who grants it access to their account.

**Authentication mechanism:**
1. User logs in via browser OAuth flow
2. App receives a user-scoped token (access to whatever the user can access)

**Problems for OpenRabbit:**
- Requires a web-based login flow — adds friction, requires a frontend
- Token is scoped to the user who authenticated, not to the organization — if that user leaves the org, the token stops working
- Rate limit: 5,000 req/hour per user (3x lower than GitHub App)
- Cannot filter by repository — if a user grants access, the token can touch all their repos
- Webhook delivery requires the user to manually configure webhooks on each repo

**Rejected because:** OAuth Apps are designed for user-facing applications that act on behalf of a user. OpenRabbit is a bot that acts on behalf of organizations. The OAuth model is fundamentally wrong for our use case.

### Option C: Personal Access Token (PAT)

A PAT is a static token generated by a specific user.

**Problems for OpenRabbit:**
- Cannot be issued programmatically — requires manual generation
- Tied to a single user account — if that account is deleted, all reviews stop
- No multi-tenant support — a single PAT can only serve one account
- Rate limit: 5,000 req/hour shared across all uses of that token
- No webhook integration support

**Rejected because:** PATs are appropriate for personal scripts and CI/CD, not for a multi-tenant SaaS-style tool.

---

## Decision

**Use GitHub App authentication exclusively.**

### GitHub App Configuration

```
App Name: OpenRabbit (or configurable for self-hosters)
Homepage URL: https://github.com/your-org/openrabbit
Webhook URL: https://your-domain.com/api/webhooks/github
Webhook Secret: [generated with openssl rand -hex 32]

Permissions:
  Pull requests: Read & Write    # post comments, read PR data
  Contents: Read                 # fetch file content at specific SHAs
  Metadata: Read                 # required for all apps
  Commit statuses: Read & Write  # post pending/success status

Events Subscribed:
  - pull_request                 # opened, synchronize, reopened, closed
  - pull_request_review_comment  # created (for "fix this" replies)
  - installation                 # created, deleted (tenant onboarding)
```

### Authentication Flow

```
┌─────────────┐     1. JWT (App-level)    ┌─────────────────┐
│  OpenRabbit │ ─────────────────────────▶│   GitHub API    │
│             │◀─────────────────────────  │                 │
│             │  2. Installation Token     │                 │
│             │                           │                 │
│             │  3. API calls with token   │                 │
│             │ ─────────────────────────▶│                 │
└─────────────┘                           └─────────────────┘
```

### JWT Generation (Python)

```python
import time
import jwt  # PyJWT library

def generate_app_jwt(app_id: str, private_key_pem: str) -> str:
    """
    Generate a short-lived JWT for GitHub App authentication.
    Valid for 10 minutes (GitHub's maximum).
    """
    now = int(time.time())
    payload = {
        "iat": now - 60,    # issued-at (60s in the past to account for clock drift)
        "exp": now + 540,   # expires in 9 minutes (GitHub max is 10)
        "iss": app_id,      # issuer = GitHub App ID
    }
    return jwt.encode(payload, private_key_pem, algorithm="RS256")
```

### Installation Token Exchange

```python
async def get_installation_token(installation_id: int) -> str:
    """Exchange App JWT for installation-scoped access token."""
    jwt_token = generate_app_jwt(settings.github_app_id, settings.private_key)
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"https://api.github.com/app/installations/{installation_id}/access_tokens",
            headers={
                "Authorization": f"Bearer {jwt_token}",
                "Accept": "application/vnd.github+json",
                "X-GitHub-Api-Version": "2022-11-28",
            }
        )
        response.raise_for_status()
        data = response.json()
        return data["token"]  # expires at data["expires_at"] (1 hour from now)
```

---

## Consequences

### Positive
- Each installation (organization or user) gets its own installation token — tokens are naturally scoped to the correct repositories
- 15,000 API requests/hour per installation means even high-volume engineering orgs won't hit limits under normal PR activity (a typical org makes <500 GitHub API calls/hour)
- Admins see exactly which repositories OpenRabbit can access and can revoke at any time via GitHub's UI
- No user login UI required — the installation flow is entirely handled by GitHub's standard app installation page
- `installation.id` in every webhook payload gives us the tenant key with zero lookup required

### Negative
- Private key (`.pem` file) must be stored securely and never committed to git. **Mitigation:** documented in README, enforced via `.gitignore`, checked in CI via `git-secrets`
- App-level JWT must be regenerated every 10 minutes — adds a code path for token management. **Mitigation:** solved by ADR-0012 (Redis-based token caching)
- Self-hosted deployments require the user to create their own GitHub App — adds ~30 minutes of setup. **Mitigation:** `scripts/setup.sh` walks through this interactively

### Neutral
- The `installation_id` is the primary tenant identifier throughout the entire codebase — every database record, every Celery task argument, every Redis key includes it

---

## Security Considerations

1. **Private key storage:** Store as a `.pem` file referenced by path in `.env`. Never store in the database. Never include in Docker images — mount as a volume secret.
2. **Webhook secret:** Separate from the private key. Used for HMAC validation only (see ADR-0004).
3. **Token rotation:** Installation tokens expire after 1 hour. Our caching strategy (ADR-0012) ensures we never use an expired token.
4. **Minimum permissions:** Request only the permissions listed above. Never request `Administration`, `Members`, or any write access beyond pull requests.
